## ğŸš€ Clean Code & SOLID Principles in Delphi 12.3 Athens

[![Delphi Version](https://img.shields.io/badge/Delphi-12.3%20Athens-blueviolet)](https://www.embarcadero.com/products/delphi)
[![License](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
[![SOLID](https://img.shields.io/badge/Principles-SOLID-brightgreen.svg)](https://en.wikipedia.org/wiki/SOLID)
[![Status](https://img.shields.io/badge/Status-Active-success.svg)]()

RepositÃ³rio de exemplo demonstrando a aplicaÃ§Ã£o dos princÃ­pios **SOLID** e conceitos de **Clean Code** em um projeto **Delphi 12.3 Athens**. O objetivo Ã© fornecer um guia prÃ¡tico e didÃ¡tico para desenvolvedores Delphi que desejam escrever um cÃ³digo mais limpo, manutenÃ­vel e testÃ¡vel.

---

### ğŸ“š Tabela de ConteÃºdos

1.  [IntroduÃ§Ã£o: Por que Clean Code?](#-introduÃ§Ã£o-por-que-clean-code)
2.  [Recursos Modernos do Delphi 12.3](#-recursos-modernos-do-delphi-123-facilitando-o-clean-code)
3.  [Estrutura do Projeto](#-estrutura-do-projeto)
4.  [Arquitetura do Sistema](#-arquitetura-do-sistema)
    *   [Diagrama de Arquitetura em Camadas](#-diagrama-de-arquitetura-em-camadas)
    *   [Diagrama de Classes UML](#-diagrama-de-classes-uml)
    *   [Diagrama de SequÃªncia do Processamento](#-diagrama-de-sequÃªncia-do-processamento)
    *   [Diagrama de InjeÃ§Ã£o de DependÃªncia](#-diagrama-de-injeÃ§Ã£o-de-dependÃªncia)
5.  [Os 5 PrincÃ­pios SOLID](#-os-5-princÃ­pios-solid)
    *   [Mindmap dos PrincÃ­pios SOLID (Corrigido)](#-mindmap-dos-princÃ­pios-solid-corrigido)
    *   [S - Single Responsibility Principle (SRP)](#s---single-responsibility-principle-srp)
    *   [O - Open/Closed Principle (OCP)](#o---openclosed-principle-ocp)
    *   [L - Liskov Substitution Principle (LSP)](#l---liskov-substitution-principle-lsp)
    *   [I - Interface Segregation Principle (ISP)](#i---interface-segregation-principle-isp)
    *   [D - Dependency Inversion Principle (DIP)](#d---dependency-inversion-principle-dip)
6.  [PrÃ©-requisitos](#-prÃ©-requisitos)
7.  [InstalaÃ§Ã£o e ConfiguraÃ§Ã£o](#-instalaÃ§Ã£o-e-configuraÃ§Ã£o)
8.  [Como Executar o Projeto](#-como-executar-o-projeto)
9.  [Como Executar os Testes](#-como-executar-os-testes)
10. [BenefÃ­cios da Arquitetura Limpa](#-benefÃ­cios-da-arquitetura-limpa)
11. [Como Contribuir](#-como-contribuir)
12. [LicenÃ§a](#-licenÃ§a)
13. [Links Ãšteis e ReferÃªncias](#-links-Ãºteis-e-referÃªncias)

---

### ğŸ¯ IntroduÃ§Ã£o: Por que Clean Code?

CÃ³digo limpo Ã© um cÃ³digo que pode ser lido, entendido e modificado por qualquer desenvolvedor com facilidade. Ele Ã© organizado, segue convenÃ§Ãµes e Ã© construÃ­do sobre uma arquitetura sÃ³lida. Os princÃ­pios SOLID sÃ£o a base para alcanÃ§ar essa arquitetura. Este projeto materializa esses conceitos em um cenÃ¡rio prÃ¡tico: um serviÃ§o de processamento de pedidos.

### âœ¨ Recursos Modernos do Delphi 12.3 Facilitando o Clean Code

O Delphi 12.3 Athens introduz e aprimora recursos que tornam a escrita de cÃ³digo limpo mais natural:

*   **InferÃªncia de Tipo com `var`**: Reduz a verbosidade na declaraÃ§Ã£o de variÃ¡veis.
    ```pascal
    var Validator := TOrderValidator.Create; // O compilador infere o tipo
    ```
*   **VariÃ¡veis Inline**: Permite declarar variÃ¡veis no ponto de uso, melhorando a localidade e a legibilidade.
    ```pascal
    if AOrder.IsValid(var ValidationMessage: string) then
      // Usa ValidationMessage aqui
    ```
*   **Managed Records**: Perfeitos para DTOs (Data Transfer Objects) e Entidades, pois gerenciam seu prÃ³prio ciclo de vida, evitando vazamentos de memÃ³ria e simplificando o cÃ³digo.
*   **Melhorias na Sintaxe**: Pequenas melhorias que tornam o cÃ³digo mais expressivo e menos propenso a erros.

### ğŸ“ Estrutura do Projeto

A estrutura de pastas foi organizada para separar claramente as responsabilidades, facilitando a navegaÃ§Ã£o e a manutenÃ§Ã£o.

```
/
â”œâ”€â”€ CleanCodeDelphi.dpr
â”œâ”€â”€ CleanCodeDelphi.dproj
â”œâ”€â”€ README.md
â””â”€â”€ src/
    â”œâ”€â”€ entities/
    â”‚   â””â”€â”€ OrderEntities.pas       // ContÃ©m TOrder e TOrderItem
    â”œâ”€â”€ exceptions/
    â”‚   â””â”€â”€ CustomExceptions.pas    // ExceÃ§Ãµes customizadas como EOrderValidationException
    â”œâ”€â”€ interfaces/
    â”‚   â””â”€â”€ OrderInterfaces.pas     // ContÃ©m todas as interfaces (IOrder*, etc.)
    â”œâ”€â”€ mocks/
    â”‚   â”œâ”€â”€ MockNotificationService.pas // ImplementaÃ§Ã£o falsa para testes
    â”‚   â””â”€â”€ MockOrderRepository.pas   // ImplementaÃ§Ã£o falsa para testes
    â”œâ”€â”€ services/
    â”‚   â”œâ”€â”€ OrderCalculator.pas     // ImplementaÃ§Ã£o de IOrderCalculator
    â”‚   â”œâ”€â”€ OrderService.pas        // Orquestrador principal (TOrderService)
    â”‚   â””â”€â”€ OrderValidator.pas      // ImplementaÃ§Ã£o de IOrderValidator
    â””â”€â”€ tests/
        â””â”€â”€ TestOrderService.pas    // Testes unitÃ¡rios para TOrderService
```

### ğŸ›ï¸ Arquitetura do Sistema

A arquitetura Ã© projetada em torno da InversÃ£o de DependÃªncia, permitindo baixo acoplamento e alta coesÃ£o.

#### ğŸ—ï¸ Diagrama de Arquitetura em Camadas

Este diagrama mostra como as dependÃªncias fluem apenas em uma direÃ§Ã£o, das camadas superiores para as inferiores, sempre dependendo de abstraÃ§Ãµes.

```mermaid
graph TD
    subgraph A[ApresentaÃ§Ã£o]
        direction LR
        ConsoleApp(Console App)
    end

    subgraph B[ServiÃ§os/OrquestraÃ§Ã£o]
        direction LR
        OrderService(TOrderService)
    end

    subgraph C[AbstraÃ§Ãµes (Interfaces)]
        direction LR
        IOrderValidator(IOrderValidator)
        IOrderCalculator(IOrderCalculator)
        IOrderRepository(IOrderRepository)
        IOrderNotifier(IOrderNotifier)
    end

    subgraph D[DomÃ­nio]
        direction LR
        Entities(TOrder, TOrderItem)
    end

    subgraph E[Infraestrutura/ImplementaÃ§Ãµes]
        direction LR
        ValidatorImpl(TOrderValidator)
        CalculatorImpl(TOrderCalculator)
        RepositoryImpl(TMockOrderRepository)
        NotifierImpl(TMockNotificationService)
    end

    ConsoleApp --> OrderService
    OrderService --> IOrderValidator
    OrderService --> IOrderCalculator
    OrderService --> IOrderRepository
    OrderService --> IOrderNotifier

    IOrderValidator -.-> ValidatorImpl
    IOrderCalculator -.-> CalculatorImpl
    IOrderRepository -.-> RepositoryImpl
    IOrderNotifier -.-> NotifierImpl

    OrderService --> Entities
    ValidatorImpl --> Entities

    classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px;
    classDef layer fill:#E6E6FA,stroke:#9370DB,stroke-width:2px;
    class A,B,C,D,E layer;
```

#### ğŸ”— Diagrama de Classes UML

Este diagrama ilustra as relaÃ§Ãµes entre as interfaces e suas implementaÃ§Ãµes concretas e mocks.

```mermaid
classDiagram
    direction LR

    class IOrderValidator {
        <<interface>>
        +IsValid(order: TOrder): Boolean
    }
    class IOrderCalculator {
        <<interface>>
        +CalculateTotal(order: TOrder): Currency
    }
    class IOrderRepository {
        <<interface>>
        +Save(order: TOrder): Integer
    }
    class IOrderNotifier {
        <<interface>>
        +Notify(orderId: Integer; message: string)
    }

    class TOrderValidator {
        +IsValid(order: TOrder): Boolean
    }
    class TOrderCalculator {
        +CalculateTotal(order: TOrder): Currency
    }
    class TMockOrderRepository {
        +Save(order: TOrder): Integer
    }
    class TMockNotificationService {
        +Notify(orderId: Integer; message: string)
    }

    TOrderValidator ..|> IOrderValidator : implements
    TOrderCalculator ..|> IOrderCalculator : implements
    TMockOrderRepository ..|> IOrderRepository : implements
    TMockNotificationService ..|> IOrderNotifier : implements

    TOrderService o-- "1" IOrderValidator
    TOrderService o-- "1" IOrderCalculator
    TOrderService o-- "1" IOrderRepository
    TOrderService o-- "1" IOrderNotifier

    class TOrderService {
        - FValidator: IOrderValidator
        - FCalculator: IOrderCalculator
        - FRepository: IOrderRepository
        - FNotifier: IOrderNotifier
        + ProcessOrder(order: TOrder): Integer
    }
```

#### âš¡ Diagrama de SequÃªncia do Processamento

Mostra o fluxo de chamadas quando `TOrderService.ProcessOrder` Ã© executado.

```mermaid
sequenceDiagram
    participant ConsoleApp
    participant Service as TOrderService
    participant Validator as IOrderValidator
    participant Calculator as IOrderCalculator
    participant Repo as IOrderRepository
    participant Notifier as IOrderNotifier

    ConsoleApp ->>+ Service: ProcessOrder(order)
    Service ->>+ Validator: IsValid(order)
    Validator-->>- Service: true
    Service ->>+ Calculator: CalculateTotal(order)
    Calculator-->>- Service: totalAmount
    Service ->>+ Repo: Save(order)
    Repo-->>- Service: newOrderId
    Service ->>+ Notifier: Notify(newOrderId, 'Pedido Salvo')
    Notifier-->>- Service:
    Service-->>- ConsoleApp: newOrderId
```

#### ğŸ”„ Diagrama de InjeÃ§Ã£o de DependÃªncia

Ilustra como as dependÃªncias sÃ£o "injetadas" no `TOrderService` atravÃ©s do construtor.

```mermaid
graph TD
    subgraph CompositionRoot [Ponto de CriaÃ§Ã£o (Main)]
        Validator(TOrderValidator)
        Calculator(TOrderCalculator)
        Repository(TMockOrderRepository)
        Notifier(TMockNotificationService)
    end

    subgraph ServiceLayer [Camada de ServiÃ§o]
        OrderService("TOrderService.Create(...)")
    end

    Validator --> OrderService
    Calculator --> OrderService
    Repository --> OrderService
    Notifier --> OrderService

    OrderService -->|usa| IValidator(IOrderValidator)
    OrderService -->|usa| ICalculator(IOrderCalculator)
    OrderService -->|usa| IRepository(IOrderRepository)
    OrderService -->|usa| INotifier(IOrderNotifier)

    classDef dep fill:#D4F8E8,stroke:#006400;
    class Validator,Calculator,Repository,Notifier dep;
```

---

### ğŸ§  Os 5 PrincÃ­pios SOLID

SOLID Ã© um acrÃ´nimo para cinco princÃ­pios de design que visam tornar o software mais compreensÃ­vel, flexÃ­vel e manutenÃ­vel.

#### â­ Mindmap dos PrincÃ­pios SOLID (Corrigido)

Este mindmap visual resume os cinco princÃ­pios, seus conceitos e benefÃ­cios.

```mermaid
mindmap
  root((SOLID Principles))
    S(Single Responsibility)
      "Um mÃ³dulo, uma razÃ£o para mudar"
      BenefÃ­cios
        "Menor acoplamento"
        "Maior coesÃ£o"
      Exemplo
        "TOrderValidator sÃ³ valida"
        "TOrderCalculator sÃ³ calcula"
      ViolaÃ§Ã£o
        "Classe que busca, valida e salva dados"
    O(Open/Closed)
      "Aberto para extensÃ£o,"
      "fechado para modificaÃ§Ã£o"
      BenefÃ­cios
        "Estabilidade do cÃ³digo"
        "Novas features sem quebrar o existente"
      Exemplo
        "Adicionar novo `ICalculator` sem"
        "mudar `TOrderService`"
      ViolaÃ§Ã£o
        "`case` ou `if/else` gigante"
        "para tratar subtipos"
    L(Liskov Substitution)
      "Subtipos devem ser substituÃ­veis"
      "por seus tipos base"
      BenefÃ­cios
        "Hierarquias de classes confiÃ¡veis"
        "Polimorfismo seguro"
      Exemplo
        "Qualquer `IOrderRepository` (real ou mock)"
        "funciona com `TOrderService`"
      ViolaÃ§Ã£o
        "MÃ©todo da classe filha que"
        "lanÃ§a `NotImplemented`"
    I(Interface Segregation)
      "Muitas interfaces especÃ­ficas"
      "sÃ£o melhores que uma geral"
      BenefÃ­cios
        "Clientes nÃ£o dependem de mÃ©todos que nÃ£o usam"
        "Reduz acoplamento"
      Exemplo
        "`IOrderNotifier` e `IOrderRepository`"
        "sÃ£o interfaces separadas"
      ViolaÃ§Ã£o
        "Classe que implementa interface"
        "e lanÃ§a exceÃ§Ãµes para mÃ©todos nÃ£o usados"
    D(Dependency Inversion)
      "MÃ³dulos de alto nÃ­vel nÃ£o devem depender"
      "de baixo nÃ­vel. Ambos dependem de abstraÃ§Ãµes."
      BenefÃ­cios
        "InversÃ£o de Controle (IoC)"
        "Facilita testes e mocks"
      Exemplo
        "`TOrderService` depende de `IOrderRepository`,"
        "nÃ£o de `TMockOrderRepository`"
      ViolaÃ§Ã£o
        "Classe de serviÃ§o instanciando"
        "uma classe de acesso a dados (`TFDQuery`)"
        "diretamente dentro de um mÃ©todo"
```

#### S - Single Responsibility Principle (SRP)

> Uma classe deve ter apenas uma razÃ£o para mudar.

*   **AplicaÃ§Ã£o**: `TOrderValidator` tem a Ãºnica responsabilidade de validar um pedido. `TOrderCalculator` tem a Ãºnica responsabilidade de calcular o total. `TOrderService` orquestra o processo, mas nÃ£o conhece os detalhes da validaÃ§Ã£o ou do cÃ¡lculo.

```pascal
// Em OrderValidator.pas
type
  TOrderValidator = class(TInterfacedObject, IOrderValidator)
  public
    function IsValid(const AOrder: TOrder): Boolean;
  end;

// Em OrderCalculator.pas
type
  TOrderCalculator = class(TInterfacedObject, IOrderCalculator)
  public
    function CalculateTotal(const AOrder: TOrder): Currency;
  end;
```

#### O - Open/Closed Principle (OCP)

> Entidades de software devem ser abertas para extensÃ£o, mas fechadas para modificaÃ§Ã£o.

*   **AplicaÃ§Ã£o**: Se precisarmos de uma nova regra de cÃ¡lculo (ex: para clientes premium), podemos criar uma nova classe `TPremiumOrderCalculator` que implementa `IOrderCalculator` e injetÃ¡-la no `TOrderService` sem alterar uma linha de cÃ³digo do `TOrderService`.

#### L - Liskov Substitution Principle (LSP)

> Subtipos devem ser substituÃ­veis por seus tipos base sem alterar a corretude do programa.

*   **AplicaÃ§Ã£o**: `TOrderService` funciona com qualquer classe que implemente `IOrderRepository`. Podemos passar uma `TMockOrderRepository` (para testes) ou uma `TDatabaseOrderRepository` (para produÃ§Ã£o) e o serviÃ§o funcionarÃ¡ da mesma forma.

```pascal
// Em TestOrderService.pas (usando o mock)
FOrderService := TOrderService.Create(FValidator, FCalculator, TMockOrderRepository.Create, FNotifier);

// Em CleanCodeDelphi.dpr (usando uma implementaÃ§Ã£o real, se existisse)
var OrderService := TOrderService.Create(Validator, Calculator, TDatabaseOrderRepository.Create, Notifier);
```

#### I - Interface Segregation Principle (ISP)

> Clientes nÃ£o devem ser forÃ§ados a depender de interfaces que nÃ£o usam.

*   **AplicaÃ§Ã£o**: Em vez de uma Ãºnica interface `IOrderManager` com mÃ©todos `Validate`, `Calculate`, `Save` e `Notify`, criamos quatro interfaces distintas (`IOrderValidator`, `IOrderCalculator`, `IOrderRepository`, `IOrderNotifier`). Isso permite que as classes implementem apenas o que precisam.

#### D - Dependency Inversion Principle (DIP)

> MÃ³dulos de alto nÃ­vel nÃ£o devem depender de mÃ³dulos de baixo nÃ­vel. Ambos devem depender de abstraÃ§Ãµes.

*   **AplicaÃ§Ã£o**: Este Ã© o princÃ­pio central da nossa arquitetura. `TOrderService` (alto nÃ­vel) nÃ£o depende diretamente de `TOrderValidator` ou `TMockOrderRepository` (baixo nÃ­vel). Ele depende das abstraÃ§Ãµes `IOrderValidator` e `IOrderRepository`. As implementaÃ§Ãµes concretas sÃ£o "injetadas" de fora.

```pascal
// Construtor do TOrderService
constructor TOrderService.Create(const AValidator: IOrderValidator;
  const ACalculator: IOrderCalculator; const ARepository: IOrderRepository;
  const ANotifier: IOrderNotifier);
begin
  FValidator := AValidator;
  FCalculator := ACalculator;
  FRepository := ARepository;
  FNotifier := ANotifier;
end;
```

---

### ğŸ”§ PrÃ©-requisitos

*   **Embarcadero Delphi 12.3 Athens** (ou superior).
*   **Test DUnitX Framework**: Usado para os testes unitÃ¡rios. Pode ser instalado via **GetIt Package Manager**.

### âš™ï¸ InstalaÃ§Ã£o e ConfiguraÃ§Ã£o

1.  **Clone o repositÃ³rio:**
    ```bash
    git clone https://github.com/seu-usuario/CleanCodeDelphi.git
    ```
2.  **Abra o Delphi 12.3**.
3.  **Instale o DUnitX**:
    *   VÃ¡ em `Tools > GetIt Package Manager`.
    *   Procure por `DUnitX`.
    *   Clique em `Install`.
4.  **Abra o projeto**:
    *   VÃ¡ em `File > Open Project...`.
    *   Navegue atÃ© a pasta clonada e abra o arquivo `CleanCodeDelphi.dproj`.
5.  **Compile o projeto**: Pressione `Ctrl + F9` para garantir que todas as dependÃªncias estÃ£o corretas.

### â–¶ï¸ Como Executar o Projeto

1.  Abra o arquivo `CleanCodeDelphi.dpr`.
2.  Pressione `F9` ou clique em `Run > Run`.
3.  O console irÃ¡ exibir a saÃ­da do processamento do pedido de exemplo.

### âœ… Como Executar os Testes

1.  No `Project Manager`, clique com o botÃ£o direito em `TestOrderService.exe`.
2.  Selecione `Run`.
3.  O console do DUnitX serÃ¡ exibido com os resultados dos testes. Todos os testes devem passar.

### ğŸ† BenefÃ­cios da Arquitetura Limpa

*   **Manutenibilidade**: CÃ³digo fÃ¡cil de entender e modificar.
*   **Testabilidade**: A InjeÃ§Ã£o de DependÃªncia permite mockar componentes para testes unitÃ¡rios isolados.
*   **Flexibilidade**: Novas funcionalidades podem ser adicionadas com impacto mÃ­nimo no cÃ³digo existente.
*   **Reusabilidade**: Componentes desacoplados podem ser reutilizados em outros projetos.
*   **Escalabilidade**: A arquitetura suporta o crescimento do projeto de forma organizada.

### ğŸ¤ Como Contribuir

ContribuiÃ§Ãµes sÃ£o bem-vindas! Se vocÃª tiver sugestÃµes, melhorias ou encontrar um bug:

1.  FaÃ§a um **Fork** do projeto.
2.  Crie uma nova **Branch** (`git checkout -b feature/sua-feature`).
3.  FaÃ§a o **Commit** das suas alteraÃ§Ãµes (`git commit -m 'Adiciona nova feature'`).
4.  FaÃ§a o **Push** para a Branch (`git push origin feature/sua-feature`).
5.  Abra um **Pull Request**.

### ğŸ“œ LicenÃ§a

Este projeto estÃ¡ licenciado sob a LicenÃ§a MIT. Veja o arquivo `LICENSE` para mais detalhes.

### ğŸ”— Links Ãšteis e ReferÃªncias

*   **Clean Code: A Handbook of Agile Software Craftsmanship** - Robert C. Martin
*   **DocumentaÃ§Ã£o do Delphi 12 Athens** - Embarcadero
*   **Refactoring Guru** - PadrÃµes de Projeto e PrincÃ­pios SOLID