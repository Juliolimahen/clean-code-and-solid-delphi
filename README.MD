## Clean Code com Delphi 12.3 Athens

![Delphi](https://img.shields.io/badge/Delphi-12.3%20Athens-blue.svg)![License](https://img.shields.io/badge/License-MIT-green.svg)![Platform](https://img.shields.io/badge/Platform-Windows%20|%20Linux%20|%20macOS-orange.svg)![Principles](https://img.shields.io/badge/Principles-SOLID%20|%20Clean%20Code-purple.svg)

Este projeto √© um guia pr√°tico e um exemplo de implementa√ß√£o dos princ√≠pios **SOLID** e **Clean Code** utilizando a vers√£o mais recente do **Delphi 12.3 Athens**. O objetivo √© demonstrar como criar aplica√ß√µes robustas, manuten√≠veis, test√°veis e escal√°veis em Object Pascal moderno.

---

### üìö √çndice

1.  [Introdu√ß√£o ao Clean Code](#-introdu√ß√£o-ao-clean-code)
2.  [Recursos Modernos do Delphi 12.3 Athens](#-recursos-modernos-do-delphi-123-athens)
3.  [Estrutura do Projeto](#-estrutura-do-projeto)
4.  [Arquitetura do Sistema](#-arquitetura-do-sistema)
    *   [Diagrama de Arquitetura em Camadas](#-diagrama-de-arquitetura-em-camadas)
    *   [Diagrama de Classes UML](#-diagrama-de-classes-uml)
    *   [Diagrama de Sequ√™ncia do Processamento](#-diagrama-de-sequ√™ncia-do-processamento)
    *   [Diagrama de Inje√ß√£o de Depend√™ncia](#-diagrama-de-inje√ß√£o-de-depend√™ncia)
5.  [Os 5 Princ√≠pios SOLID](#-os-5-princ√≠pios-solid)
    *   [Mindmap dos Princ√≠pios SOLID](#-mindmap-dos-princ√≠pios-solid)
    *   [1. Single Responsibility Principle (SRP)](#1-single-responsibility-principle-srp)
    *   [2. Open/Closed Principle (OCP)](#2-openclosed-principle-ocp)
    *   [3. Liskov Substitution Principle (LSP)](#3-liskov-substitution-principle-lsp)
    *   [4. Interface Segregation Principle (ISP)](#4-interface-segregation-principle-isp)
    *   [5. Dependency Inversion Principle (DIP)](#5-dependency-inversion-principle-dip)
6.  [Pr√©-requisitos e Instala√ß√£o](#-pr√©-requisitos-e-instala√ß√£o)
7.  [Executando o Projeto e os Testes](#-executando-o-projeto-e-os-testes)
8.  [Benef√≠cios da Arquitetura Limpa](#-benef√≠cios-da-arquitetura-limpa)
9.  [Como Contribuir](#-como-contribuir)
10. [Licen√ßa](#-licen√ßa)
11. [Links √öteis e Refer√™ncias](#-links-√∫teis-e-refer√™ncias)

---

### ‚≠ê Introdu√ß√£o ao Clean Code

Clean Code (C√≥digo Limpo) n√£o √© apenas c√≥digo que funciona; √© c√≥digo que √© f√°cil de ler, entender e manter por outros desenvolvedores (ou por voc√™ mesmo no futuro). Um c√≥digo limpo segue conven√ß√µes, possui nomes significativos, fun√ß√µes pequenas e focadas, e uma arquitetura bem definida. Este projeto serve como um exemplo pr√°tico de como aplicar esses conceitos em Delphi.

### ‚ú® Recursos Modernos do Delphi 12.3 Athens

O Delphi 12.3 traz v√°rias funcionalidades que facilitam a escrita de c√≥digo limpo e moderno, todas aplicadas neste projeto:

*   **Infer√™ncia de Tipo com `var`**: Reduz a verbosidade na declara√ß√£o de vari√°veis locais.
    ```pascal
    var Validator := TOrderValidator.Create; // O compilador infere o tipo
    ```
*   **Vari√°veis Inline**: Permite declarar vari√°veis no exato local onde s√£o usadas, melhorando a legibilidade e o escopo.
    ```pascal
    if not FValidator.IsValid(AOrder, var ValidationErrors) then
      Exit(False);
    ```
*   **Managed Records**: Perfeitos para criar DTOs (Data Transfer Objects) e Entidades imut√°veis sem o overhead de classes, com gerenciamento autom√°tico de mem√≥ria.
    ```pascal
    // TOrderItem √© um Managed Record em Core.Entities.pas
    var Item := TOrderItem.New('Delphi License', 1, 150.0);
    ```

### üìÅ Estrutura do Projeto

A estrutura de diret√≥rios foi organizada para separar claramente as responsabilidades, refletindo a arquitetura em camadas.

```
/CleanCodeDelphi/
‚îú‚îÄ‚îÄ ProjectSOLID.dpr                    // Arquivo principal do projeto e ponto de inje√ß√£o de depend√™ncia
‚îú‚îÄ‚îÄ Core/
‚îÇ   ‚îú‚îÄ‚îÄ Core.Interfaces.pas             // Contratos (interfaces) da aplica√ß√£o
‚îÇ   ‚îî‚îÄ‚îÄ Core.Entities.pas               // Entidades de dom√≠nio (TOrder, TOrderItem)
‚îú‚îÄ‚îÄ Application/
‚îÇ   ‚îú‚îÄ‚îÄ Application.Services.pas        // Orquestra√ß√£o e l√≥gica de aplica√ß√£o (TOrderService)
‚îÇ   ‚îî‚îÄ‚îÄ Application.Validators.pas      // Implementa√ß√£o da valida√ß√£o de regras de neg√≥cio
‚îú‚îÄ‚îÄ Infrastructure/
‚îÇ   ‚îú‚îÄ‚îÄ Infrastructure.Repositories.pas // Implementa√ß√£o de reposit√≥rios (TInMemoryOrderRepository)
‚îÇ   ‚îú‚îÄ‚îÄ Infrastructure.Notifications.pas// Implementa√ß√£o de notifica√ß√µes (TEmailNotificationService)
‚îÇ   ‚îî‚îÄ‚îÄ Infrastructure.PaymentProviders.pas // Implementa√ß√£o de provedores de pagamento
‚îú‚îÄ‚îÄ UI/
‚îÇ   ‚îú‚îÄ‚îÄ UI.MainForm.pas                 // Camada de apresenta√ß√£o (formul√°rio principal)
‚îÇ   ‚îî‚îÄ‚îÄ UI.MainForm.dfm                 // Design do formul√°rio
‚îî‚îÄ‚îÄ Tests/
    ‚îú‚îÄ‚îÄ Tests.OrderService.pas          // Testes unit√°rios para TOrderService
    ‚îî‚îÄ‚îÄ Tests.Mocks.pas                 // Mocks das depend√™ncias para testes isolados
```

### üèóÔ∏è Arquitetura do Sistema

A arquitetura do projeto √© baseada em camadas e no princ√≠pio da invers√£o de depend√™ncia, garantindo baixo acoplamento e alta coes√£o.

#### ‚≠ê Diagrama de Arquitetura em Camadas

Este diagrama mostra a separa√ß√£o de responsabilidades e a dire√ß√£o das depend√™ncias (setas apontam para quem √© conhecido). A camada UI depende da camada de Aplica√ß√£o, que por sua vez depende apenas das Interfaces do Core. As implementa√ß√µes da Infraestrutura dependem das mesmas interfaces.

```mermaid
graph TD
    subgraph "Apresenta√ß√£o (UI)"
        A[UI.MainForm]
    end
    subgraph "Aplica√ß√£o (Application)"
        B[Application.Services - TOrderService]
    end
    subgraph "Dom√≠nio & Interfaces (Core)"
        C[Core.Interfaces]
        D[Core.Entities]
    end
    subgraph "Infraestrutura (Infrastructure)"
        E[Repositories, Notifications, PaymentProviders]
    end

    A --> B
    B --> C
    B --> D
    E --> C
```

#### ‚≠ê Diagrama de Classes UML

Este diagrama ilustra a rela√ß√£o entre as abstra√ß√µes (interfaces) e suas implementa√ß√µes concretas. O `TOrderService` depende das interfaces, n√£o das classes concretas.

```mermaid
classDiagram
    class IOrderRepository {
        <<Interface>>
        +Save(order: TOrder): Boolean
    }
    class IOrderValidator {
        <<Interface>>
        +IsValid(order: TOrder): Boolean
    }
    class IPaymentProvider {
        <<Interface>>
        +ProcessPayment(order: TOrder): Boolean
    }
    class INotificationService {
        <<Interface>>
        +SendConfirmation(order: TOrder): Boolean
    }
    class TInMemoryOrderRepository {
        +Save(order: TOrder): Boolean
    }
    class TOrderValidator {
        +IsValid(order: TOrder): Boolean
    }
    class TCreditCardProvider {
        +ProcessPayment(order: TOrder): Boolean
    }
    class TEmailNotificationService {
        +SendConfirmation(order: TOrder): Boolean
    }
    class TOrderService {
        -FRepository: IOrderRepository
        -FValidator: IOrderValidator
        -FNotifier: INotificationService
        +ProcessOrder(order: TOrder, provider: IPaymentProvider): Boolean
    }

    TInMemoryOrderRepository --|> IOrderRepository
    TOrderValidator --|> IOrderValidator
    TCreditCardProvider --|> IPaymentProvider
    TEmailNotificationService --|> INotificationService
    TOrderService o-- "1" IOrderRepository
    TOrderService o-- "1" IOrderValidator
    TOrderService o-- "1" INotificationService
    TOrderService ..> IPaymentProvider : "usa"
```

#### ‚≠ê Diagrama de Sequ√™ncia do Processamento

O diagrama a seguir detalha o fluxo de uma chamada para processar um pedido.

```mermaid
sequenceDiagram
    participant UI as UI.MainForm
    participant Service as TOrderService
    participant Validator as IOrderValidator
    participant Payment as IPaymentProvider
    participant Repository as IOrderRepository
    participant Notifier as INotificationService

    UI->>+Service: ProcessOrder(Order, PaymentProvider)
    Service->>+Validator: IsValid(Order)
    Validator-->>-Service: Boolean (true)
    Service->>+Payment: ProcessPayment(Order)
    Payment-->>-Service: Boolean (true)
    Service->>+Repository: Save(Order)
    Repository-->>-Service: Boolean (true)
    Service->>+Notifier: SendConfirmation(Order)
    Notifier-->>-Service: Boolean (true)
    Service-->>-UI: "Pedido processado com sucesso"
```

#### ‚≠ê Diagrama de Inje√ß√£o de Depend√™ncia

Ilustra como as depend√™ncias s√£o "injetadas" no `TOrderService` atrav√©s do construtor, centralizado no arquivo `.dpr`.

```mermaid
graph TD
    A[ProjectSOLID.dpr] --> B{Cria TOrderValidator};
    A --> C{Cria TInMemoryOrderRepository};
    A --> D{Cria TEmailNotificationService};
    B --> E{Injeta no Construtor do TOrderService};
    C --> E{Injeta no Construtor do TOrderService};
    D --> E{Injeta no Construtor do TOrderService};
    E --> F[TOrderService est√° pronto para usar];
```

### üß† Os 5 Princ√≠pios SOLID

#### ‚≠ê Mindmap dos Princ√≠pios SOLID

```mermaid
mindmap
  root((SOLID))
    S[S: Responsabilidade √önica]
      (Uma classe, um motivo para mudar)
      (Benef√≠cio: Alta coes√£o)
    O[O: Aberto/Fechado]
      (Aberto para extens√£o)
      (Fechado para modifica√ß√£o)
      (Benef√≠cio: Estabilidade)
    L[L: Substitui√ß√£o de Liskov]
      (Subtipos substitu√≠veis por tipos base)
      (Benef√≠cio: Polimorfismo seguro)
    I[I: Segrega√ß√£o de Interfaces]
      (Interfaces pequenas e espec√≠ficas)
      (Benef√≠cio: Evita acoplamento desnecess√°rio)
    D[D: Invers√£o de Depend√™ncia]
      (Depender de abstra√ß√µes, n√£o de implementa√ß√µes)
      (Benef√≠cio: Desacoplamento, testabilidade)
```

---

#### 1. Single Responsibility Principle (SRP)
*Uma classe deve ter um, e apenas um, motivo para mudar.*

No nosso projeto, cada classe tem uma tarefa bem definida:
*   **`TOrder`**: Apenas cont√©m os dados do pedido. Sua responsabilidade √© representar a entidade Pedido.
*   **`TOrderValidator`**: Sua √∫nica responsabilidade √© validar as regras de neg√≥cio de um pedido.
*   **`TInMemoryOrderRepository`**: Sua √∫nica responsabilidade √© persistir o pedido (neste caso, em mem√≥ria).
*   **`TEmailNotificationService`**: Sua √∫nica responsabilidade √© enviar uma notifica√ß√£o de confirma√ß√£o.

#### 2. Open/Closed Principle (OCP)
*Objetos ou entidades devem ser abertos para extens√£o, mas fechados para modifica√ß√£o.*

O melhor exemplo no projeto √© o sistema de pagamento. `TOrderService` n√£o conhece os detalhes de `TCreditCardProvider` ou `TPixProvider`. Ele apenas trabalha com a interface `IPaymentProvider`.

Para adicionar uma nova forma de pagamento (Ex: PayPal), basta criar uma nova classe que implementa `IPaymentProvider`. **Nenhuma altera√ß√£o √© necess√°ria em `TOrderService`**.

```pascal
// C√≥digo existente
type
  IPaymentProvider = interface
    ['{...}']
    function ProcessPayment(const AOrder: TOrder): Boolean;
    function GetName: string;
  end;

// Nova Extens√£o (novo arquivo, sem alterar c√≥digo existente)
type
  TPayPalProvider = class(TInterfacedObject, IPaymentProvider)
  public
    function ProcessPayment(const AOrder: TOrder): Boolean;
    function GetName: string;
  end;
```

#### 3. Liskov Substitution Principle (LSP)
*Subtipos devem ser substitu√≠veis por seus tipos base sem alterar a corre√ß√£o do programa.*

Todas as classes que implementam uma interface neste projeto (como `TCreditCardProvider` e `TPixProvider` implementando `IPaymentProvider`) respeitam este princ√≠pio. O `TOrderService` pode receber qualquer uma delas e o comportamento esperado (processar um pagamento) ser√° mantido, sem quebrar a l√≥gica da aplica√ß√£o.

#### 4. Interface Segregation Principle (ISP)
*Clientes n√£o devem ser for√ßados a depender de interfaces que n√£o usam.*

Em vez de uma √∫nica interface "gigante" `IOrderOperations`, criamos interfaces pequenas e coesas para cada responsabilidade:
*   `IOrderValidator`
*   `IOrderRepository`
*   `IPaymentProvider`
*   `INotificationService`

Isso garante que uma classe que precisa apenas salvar um pedido (como um logger de auditoria, por exemplo) dependa apenas de `IOrderRepository`, e n√£o seja for√ßada a conhecer m√©todos de valida√ß√£o ou pagamento.

#### 5. Dependency Inversion Principle (DIP)
*M√≥dulos de alto n√≠vel n√£o devem depender de m√≥dulos de baixo n√≠vel. Ambos devem depender de abstra√ß√µes.*

Na pr√°tica, isso √© alcan√ßado com **Inje√ß√£o de Depend√™ncia**. O m√≥dulo de alto n√≠vel `TOrderService` n√£o cria suas pr√≥prias depend√™ncias (`TOrderValidator`, `TInMemoryOrderRepository`). Em vez disso, ele depende das abstra√ß√µes (`IOrderValidator`, `IOrderRepository`) e as recebe via construtor.

*   **Ruim**: O servi√ßo cria suas pr√≥prias depend√™ncias (acoplamento forte).
    ```pascal
    constructor TOrderService.Create;
    begin
      FRepository := TInMemoryOrderRepository.Create; // Acoplado!
      FValidator := TOrderValidator.Create; // Imposs√≠vel de testar sem as classes concretas.
    end;
    ```

*   **Bom (implementado no projeto)**: As depend√™ncias s√£o injetadas via construtor.
    ```pascal
    // Em Application.Services.pas
    type
      TOrderService = class(TInterfacedObject, IOrderService)
      private
        FValidator: IOrderValidator;
        FRepository: IOrderRepository;
        FNotifier: INotificationService;
      public
        constructor Create(const AValidator: IOrderValidator;
          const ARepository: IOrderRepository; const ANotifier: INotificationService);
      end;

    // Em ProjectSOLID.dpr, onde as depend√™ncias s√£o montadas:
    begin
      Application.Initialize;
      var Validator: IOrderValidator := TOrderValidator.Create;
      var Repository: IOrderRepository := TInMemoryOrderRepository.Create;
      var Notifier: INotificationService := TEmailNotificationService.Create;
      var OrderService: IOrderService := TOrderService.Create(Validator, Repository, Notifier); // Injetando

      Application.CreateForm(TfrmMain, frmMain);
      frmMain.SetOrderService(OrderService); // Passando o servi√ßo para o formul√°rio
      Application.Run;
    end.
    ```

### üîß Pr√©-requisitos e Instala√ß√£o

1.  **Delphi 12.3 Athens**: √â necess√°rio ter o RAD Studio 12.3 ou Delphi 12.3 instalado.
2.  **DUnitX**: Para rodar os testes unit√°rios (geralmente inclu√≠do no Delphi).

**Passos para Instala√ß√£o:**
1.  Clone o reposit√≥rio: `git clone https://github.com/your-username/CleanCodeDelphi.git`
2.  Abra o arquivo `ProjectSOLID.dproj` no Delphi 12.3.
3.  Compile o projeto (Shift + F9).

### üöÄ Executando o Projeto e os Testes

*   **Executar a Aplica√ß√£o**: Pressione `F9` ou v√° em `Run > Run`. Clique nos bot√µes para simular o processamento de pedidos com diferentes formas de pagamento. O log na tela mostrar√° o fluxo de execu√ß√£o.
*   **Executar os Testes**:
    1.  No `Project Manager`, clique com o bot√£o direito em `TestRunner.dpr` e selecione `Run`.
    2.  A janela do DUnitX aparecer√°, executando todos os testes definidos em `Tests.OrderService.pas` e mostrando os resultados. Os testes usam *mocks* (`Tests.Mocks.pas`) para garantir que a l√≥gica do `TOrderService` seja testada de forma isolada.

### üëç Benef√≠cios da Arquitetura Limpa

*   **Testabilidade**: A inje√ß√£o de depend√™ncia permite substituir implementa√ß√µes reais por mocks, facilitando testes unit√°rios r√°pidos e confi√°veis.
*   **Manutenibilidade**: C√≥digo organizado, coeso e com baixo acoplamento √© mais f√°cil de entender, corrigir e evoluir.
*   **Flexibilidade**: A troca de componentes (ex: mudar `TInMemoryOrderRepository` para um que usa FireDAC) se torna mais simples, afetando apenas a camada de infraestrutura.
*   **Escalabilidade**: A separa√ß√£o de responsabilidades permite que diferentes partes do sistema evoluam de forma independente.

### ü§ù Como Contribuir

Contribui√ß√µes s√£o muito bem-vindas! Se voc√™ deseja melhorar este projeto:

1.  Fa√ßa um **Fork** do reposit√≥rio.
2.  Crie uma nova **Branch** para sua feature (`git checkout -b feature/AmazingFeature`).
3.  Fa√ßa o **Commit** de suas altera√ß√µes (`git commit -m 'Add some AmazingFeature'`).
4.  Fa√ßa o **Push** para a Branch (`git push origin feature/AmazingFeature`).
5.  Abra um **Pull Request**.

### üìÑ Licen√ßa

Este projeto est√° licenciado sob a Licen√ßa MIT.

### üîó Links √öteis e Refer√™ncias

*   **Clean Code: A Handbook of Agile Software Craftsmanship** por Robert C. Martin.
*   **Documenta√ß√£o Oficial do Delphi**: [docwiki.embarcadero.com](https://docwiki.embarcadero.com/RADStudio/en/Main_Page)
*   **Blog da Embarcadero**: [blogs.embarcadero.com](https://blogs.embarcadero.com/)
*   **Reposit√≥rio `delphi-books`**: [github.com/PacktPublishing/Delphi-Books](https://github.com/PacktPublishing/Delphi-Books)