## Clean Code com Delphi 12.3 Athens

![Delphi](https://img.shields.io/badge/Delphi-12.3%20Athens-blue.svg)![License](https://img.shields.io/badge/License-MIT-green.svg)![Platform](https://img.shields.io/badge/Platform-Windows%20|%20Linux%20|%20macOS-orange.svg)![Principles](https://img.shields.io/badge/Principles-SOLID%20|%20Clean%20Code-purple.svg)

Este projeto √© um guia pr√°tico e um exemplo de implementa√ß√£o dos princ√≠pios **SOLID** e **Clean Code** utilizando a vers√£o mais recente do **Delphi 12.3 Athens**. O objetivo √© demonstrar como criar aplica√ß√µes robustas, manuten√≠veis, test√°veis e escal√°veis em Object Pascal moderno.

---

### üìö √çndice

1.  [Introdu√ß√£o ao Clean Code](#-introdu√ß√£o-ao-clean-code)
2.  [Recursos Modernos do Delphi 12.3 Athens](#-recursos-modernos-do-delphi-123-athens)
3.  [Estrutura do Projeto](#-estrutura-do-projeto)
4.  [Arquitetura do Sistema](#-arquitetura-do-sistema)
    *   [Diagrama de Arquitetura em Camadas](#-diagrama-de-arquitetura-em-camadas)
    *   [Diagrama de Classes UML](#-diagrama-de-classes-uml)
    *   [Diagrama de Sequ√™ncia do Processamento](#-diagrama-de-sequ√™ncia-do-processamento)
    *   [Diagrama de Inje√ß√£o de Depend√™ncia](#-diagrama-de-inje√ß√£o-de-depend√™ncia)
5.  [Os 5 Princ√≠pios SOLID](#-os-5-princ√≠pios-solid)
    *   [Mindmap dos Princ√≠pios SOLID](#-mindmap-dos-princ√≠pios-solid-corrigido)
    *   [1. Single Responsibility Principle (SRP)](#1-single-responsibility-principle-srp)
    *   [2. Open/Closed Principle (OCP)](#2-openclosed-principle-ocp)
    *   [3. Liskov Substitution Principle (LSP)](#3-liskov-substitution-principle-lsp)
    *   [4. Interface Segregation Principle (ISP)](#4-interface-segregation-principle-isp)
    *   [5. Dependency Inversion Principle (DIP)](#5-dependency-inversion-principle-dip)
6.  [Pr√©-requisitos e Instala√ß√£o](#-pr√©-requisitos-e-instala√ß√£o)
7.  [Executando o Projeto e os Testes](#-executando-o-projeto-e-os-testes)
8.  [Benef√≠cios da Arquitetura Limpa](#-benef√≠cios-da-arquitetura-limpa)
9.  [Como Contribuir](#-como-contribuir)
10. [Licen√ßa](#-licen√ßa)
11. [Links √öteis e Refer√™ncias](#-links-√∫teis-e-refer√™ncias)

---

### ‚≠ê Introdu√ß√£o ao Clean Code

Clean Code (C√≥digo Limpo) n√£o √© apenas c√≥digo que funciona; √© c√≥digo que √© f√°cil de ler, entender e manter por outros desenvolvedores (ou por voc√™ mesmo no futuro). Um c√≥digo limpo segue conven√ß√µes, possui nomes significativos, fun√ß√µes pequenas e focadas, e uma arquitetura bem definida. Este projeto serve como um exemplo pr√°tico de como aplicar esses conceitos em Delphi.

### ‚ú® Recursos Modernos do Delphi 12.3 Athens

O Delphi 12.3 traz v√°rias funcionalidades que facilitam a escrita de c√≥digo limpo e moderno:

*   **Infer√™ncia de Tipo com `var`**: Reduz a verbosidade na declara√ß√£o de vari√°veis locais.
    ```pascal
    var Validator := TOrderValidator.Create; // O compilador infere o tipo
    ```
*   **Vari√°veis Inline**: Permite declarar vari√°veis no exato local onde s√£o usadas, melhorando a legibilidade e o escopo.
    ```pascal
    if AOrder.IsValid(var ValidationMessage: string) then
      ShowMessage('V√°lido')
    else
      ShowMessage(ValidationMessage);
    ```
*   **Managed Records**: Perfeitos para criar DTOs (Data Transfer Objects) e Entidades imut√°veis sem o overhead de classes, com gerenciamento autom√°tico de mem√≥ria.

### üìÅ Estrutura do Projeto

A estrutura de diret√≥rios foi organizada para separar claramente as responsabilidades, facilitando a navega√ß√£o e a manuten√ß√£o.

```
/CleanCodeDelphi/
‚îú‚îÄ‚îÄ Source/
‚îÇ   ‚îú‚îÄ‚îÄ Core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Core.Domain.pas         // Entidades e exce√ß√µes do dom√≠nio
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Core.Interfaces.pas     // Contratos (interfaces) da aplica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ Infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Infrastructure.Data.pas // Implementa√ß√£o de reposit√≥rios (banco de dados, etc.)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Infrastructure.Logging.pas// Implementa√ß√£o de log
‚îÇ   ‚îú‚îÄ‚îÄ Application/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Application.Services.pas  // Orquestra√ß√£o e l√≥gica de aplica√ß√£o (Services)
‚îÇ   ‚îî‚îÄ‚îÄ Presentation/
‚îÇ       ‚îî‚îÄ‚îÄ UI.Main.pas             // Camada de apresenta√ß√£o (formul√°rio principal)
‚îú‚îÄ‚îÄ Tests/
‚îÇ   ‚îú‚îÄ‚îÄ Tests.Domain.pas          // Testes unit√°rios para o dom√≠nio
‚îÇ   ‚îî‚îÄ‚îÄ Tests.Application.pas     // Testes unit√°rios para os servi√ßos
‚îî‚îÄ‚îÄ CleanCodeDelphi.dpr             // Arquivo principal do projeto
```

### üèóÔ∏è Arquitetura do Sistema

A arquitetura do projeto √© baseada em camadas e no princ√≠pio da invers√£o de depend√™ncia, garantindo baixo acoplamento e alta coes√£o.

#### ‚≠ê Diagrama de Arquitetura em Camadas

Este diagrama mostra a separa√ß√£o de responsabilidades e a dire√ß√£o das depend√™ncias (setas apontam para quem √© conhecido). A camada de apresenta√ß√£o conhece a camada de aplica√ß√£o, que conhece as interfaces, mas n√£o as implementa√ß√µes da infraestrutura.

```mermaid
graph TD
    subgraph "Apresenta√ß√£o"
        A[UI - Formul√°rios, VCL/FMX]
    end
    subgraph "Aplica√ß√£o"
        B[Services - Orquestra√ß√£o]
    end
    subgraph "Dom√≠nio & Interfaces"
        C[Interfaces - Contratos]
        D[Entidades/Modelos de Dom√≠nio]
    end
    subgraph "Infraestrutura"
        E[Reposit√≥rios - Banco de Dados]
        F[Logging, APIs Externas]
    end

    A --> B
    B --> C
    B --> D
    E --> C
    F --> C
```

#### ‚≠ê Diagrama de Classes UML

Este diagrama ilustra a rela√ß√£o entre as abstra√ß√µes (interfaces) e suas implementa√ß√µes concretas. O `TOrderService` depende das interfaces, n√£o das classes concretas.

```mermaid
classDiagram
    class IOrderRepository {
        <<Interface>>
        +Save(order: TOrder)
    }
    class IOrderValidator {
        <<Interface>>
        +Validate(order: TOrder): Boolean
    }
    class TOrderRepositoryDB {
        +Save(order: TOrder)
    }
    class TOrderRepositoryMock {
        +Save(order: TOrder)
    }
    class TOrderValidator {
        +Validate(order: TOrder): Boolean
    }
    class TOrderService {
        -FRepository: IOrderRepository
        -FValidator: IOrderValidator
        +ProcessOrder(order: TOrder)
    }

    TOrderRepositoryDB --|> IOrderRepository
    TOrderRepositoryMock --|> IOrderRepository
    TOrderValidator --|> IOrderValidator
    TOrderService o-- "1" IOrderRepository
    TOrderService o-- "1" IOrderValidator
```

#### ‚≠ê Diagrama de Sequ√™ncia do Processamento

O diagrama a seguir detalha o fluxo de uma chamada para processar um pedido.

```mermaid
sequenceDiagram
    participant UI as Apresenta√ß√£o
    participant Service as TOrderService
    participant Validator as IOrderValidator
    participant Repository as IOrderRepository

    UI->>+Service: ProcessOrder(Order)
    Service->>+Validator: Validate(Order)
    Validator-->>-Service: Boolean (true)
    Service->>+Repository: Save(Order)
    Repository-->>-Service: void
    Service-->>-UI: "Pedido processado"
```

#### ‚≠ê Diagrama de Inje√ß√£o de Depend√™ncia

Ilustra como as depend√™ncias s√£o "injetadas" no `TOrderService` atrav√©s do construtor.

```mermaid
graph TD
    A[Ponto de Cria√ß√£o - Main] --> B{Cria TOrderValidator};
    A --> C{Cria TOrderRepositoryDB};
    B --> D{Injeta no Construtor do TOrderService};
    C --> D{Injeta no Construtor do TOrderService};
    D --> E[TOrderService est√° pronto para usar];
```

### üß† Os 5 Princ√≠pios SOLID

SOLID √© um acr√¥nimo para cinco princ√≠pios de design que visam tornar o software mais compreens√≠vel, flex√≠vel e manuten√≠vel.

#### ‚≠ê Mindmap dos Princ√≠pios SOLID (Corrigido)

Este mindmap visual resume os cinco princ√≠pios, seus conceitos e benef√≠cios.

```mermaid
mindmap
  root((SOLID))
    S[S: Responsabilidade √önica]
      (Uma classe, um motivo para mudar)
      (Benef√≠cio: Alta coes√£o)
    O[O: Aberto/Fechado]
      (Aberto para extens√£o)
      (Fechado para modifica√ß√£o)
      (Benef√≠cio: Estabilidade)
    L[L: Substitui√ß√£o de Liskov]
      (Subtipos substitu√≠veis por tipos base)
      (Benef√≠cio: Polimorfismo seguro)
    I[I: Segrega√ß√£o de Interfaces]
      (Interfaces pequenas e espec√≠ficas)
      (Benef√≠cio: Evita acoplamento desnecess√°rio)
    D[D: Invers√£o de Depend√™ncia]
      (Depender de abstra√ß√µes, n√£o de implementa√ß√µes)
      (Benef√≠cio: Desacoplamento, testabilidade)
```

---

#### 1. Single Responsibility Principle (SRP)
*Uma classe deve ter um, e apenas um, motivo para mudar.*

Isso significa que uma classe deve ter apenas uma responsabilidade ou tarefa.

*   **Ruim**: Uma classe `TOrder` que valida, calcula e salva a si mesma.
    ```pascal
    type
      TOrder = class
      public
        // Propriedades do pedido
        function Validate: Boolean;   // Responsabilidade 1
        procedure CalculateTotal;    // Responsabilidade 2
        procedure SaveToDatabase;    // Responsabilidade 3
      end;
    ```

*   **Bom**: Separa√ß√£o das responsabilidades em classes distintas.
    ```pascal
    type
      TOrder = class // Apenas dados
        // Propriedades do pedido
      end;

      TOrderValidator = class // Apenas valida√ß√£o
      public
        function IsValid(AOrder: TOrder): Boolean;
      end;

      TOrderCalculator = class // Apenas c√°lculo
      public
        function CalculateTotal(AOrder: TOrder): Currency;
      end;

      TOrderRepository = class // Apenas persist√™ncia
      public
        procedure Save(AOrder: TOrder);
      end;
    ```

#### 2. Open/Closed Principle (OCP)
*Objetos ou entidades devem ser abertos para extens√£o, mas fechados para modifica√ß√£o.*

Isso significa que voc√™ deve ser capaz de adicionar um novo comportamento sem alterar o c√≥digo-fonte existente.

*   **Ruim**: Um `case` ou `if/else` para diferentes tipos de desconto. Adicionar um novo desconto exige modificar esta fun√ß√£o.
    ```pascal
    function TOrderCalculator.CalculateDiscount(ADiscountType: TDiscountType): Currency;
    begin
      case ADiscountType of
        dtStudent: Result := FTotal * 0.1;
        dtSenior: Result := FTotal * 0.15;
        // Se um novo desconto (dtVIP) for adicionado, este c√≥digo precisa ser alterado.
      end;
    end;
    ```

*   **Bom**: Usar uma estrat√©gia (Strategy Pattern) com interfaces.
    ```pascal
    type
      IDiscountStrategy = interface
        ['{GUID}']
        function Calculate(ATotal: Currency): Currency;
      end;

      TStudentDiscount = class(TInterfacedObject, IDiscountStrategy)
      public
        function Calculate(ATotal: Currency): Currency;
      end;

      TSeniorDiscount = class(TInterfacedObject, IDiscountStrategy)
      public
        function Calculate(ATotal: Currency): Currency;
      end;

    // Para adicionar um novo desconto, basta criar uma nova classe. O c√≥digo original n√£o √© tocado.
    var
      LDiscount: IDiscountStrategy;
    begin
      LDiscount := TStudentDiscount.Create;
      FinalPrice := Total - LDiscount.Calculate(Total);
    end;
    ```

#### 3. Liskov Substitution Principle (LSP)
*Subtipos devem ser substitu√≠veis por seus tipos base sem alterar a corre√ß√£o do programa.*

Se a classe `S` √© um subtipo da classe `T`, ent√£o objetos do tipo `T` devem poder ser substitu√≠dos por objetos do tipo `S` sem quebrar a aplica√ß√£o.

*   **Ruim**: Uma classe filha que quebra o contrato da classe pai.
    ```pascal
    type
      TRectangle = class
      public
        procedure SetWidth(AValue: Integer); virtual;
        procedure SetHeight(AValue: Integer); virtual;
      end;

      TSquare = class(TRectangle) // Quadrado √© um ret√¢ngulo?
      public
        procedure SetWidth(AValue: Integer); override; // Viola o LSP
        procedure SetHeight(AValue: Integer); override; // Viola o LSP
      end;

    procedure TSquare.SetWidth(AValue: Integer);
    begin
      inherited SetWidth(AValue);
      inherited SetHeight(AValue); // Efeito colateral: altera a altura tamb√©m
    end;
    ```
    Um teste que usa `TRectangle` pode falhar se receber um `TSquare`.

*   **Bom**: Evitar heran√ßas que mudam o comportamento fundamental. Prefira composi√ß√£o ou hierarquias mais seguras. Neste caso, `TRectangle` e `TSquare` poderiam herdar de uma classe `TShape` abstrata, mas n√£o um do outro.

#### 4. Interface Segregation Principle (ISP)
*Clientes n√£o devem ser for√ßados a depender de interfaces que n√£o usam.*

√â melhor ter muitas interfaces espec√≠ficas do que uma √∫nica interface gen√©rica.

*   **Ruim**: Uma interface "faz-tudo".
    ```pascal
    type
      IWorker = interface
        ['{GUID}']
        procedure Work;
        procedure Eat;
      end;

    type
      TRobot = class(TInterfacedObject, IWorker)
      public
        procedure Work; // OK
        procedure Eat;  // Um rob√¥ n√£o come. M√©todo vazio ou exce√ß√£o.
      end;
    ```

*   **Bom**: Interfaces segregadas.
    ```pascal
    type
      IWorkable = interface
        ['{GUID}']
        procedure Work;
      end;

      IEatable = interface
        ['{GUID}']
        procedure Eat;
      end;

    type
      THuman = class(TInterfacedObject, IWorkable, IEatable) ... end;
      TRobot = class(TInterfacedObject, IWorkable) ... end; // Implementa apenas o que precisa.
    ```

#### 5. Dependency Inversion Principle (DIP)
*M√≥dulos de alto n√≠vel n√£o devem depender de m√≥dulos de baixo n√≠vel. Ambos devem depender de abstra√ß√µes.*
*Abstra√ß√µes n√£o devem depender de detalhes. Detalhes devem depender de abstra√ß√µes.*

Na pr√°tica, isso significa que devemos depender de interfaces, n√£o de classes concretas.

*   **Ruim**: O servi√ßo cria suas pr√≥prias depend√™ncias (acoplamento forte).
    ```pascal
    type
      TOrderService = class
      private
        FRepository: TOrderRepositoryDB; // Depende da classe concreta
      public
        constructor Create;
        procedure ProcessOrder(AOrder: TOrder);
      end;

    constructor TOrderService.Create;
    begin
      FRepository := TOrderRepositoryDB.Create; // Acoplado! Imposs√≠vel de testar sem o banco de dados.
    end;
    ```

*   **Bom**: As depend√™ncias s√£o injetadas via construtor (Inje√ß√£o de Depend√™ncia).
    ```pascal
    type
      TOrderService = class
      private
        FRepository: IOrderRepository; // Depende da abstra√ß√£o (interface)
      public
        constructor Create(ARepository: IOrderRepository);
        procedure ProcessOrder(AOrder: TOrder);
      end;

    constructor TOrderService.Create(ARepository: IOrderRepository);
    begin
      FRepository := ARepository; // A depend√™ncia √© recebida, n√£o criada.
    end;

    // No ponto de entrada da aplica√ß√£o (Main):
    var
      Service: TOrderService;
      Repository: IOrderRepository;
    begin
      Repository := TOrderRepositoryDB.Create; // Implementa√ß√£o real
      Service := TOrderService.Create(Repository);

      // Em um teste unit√°rio:
      Repository := TOrderRepositoryMock.Create; // Implementa√ß√£o de teste (mock)
      Service := TOrderService.Create(Repository);
    end;
    ```

### üîß Pr√©-requisitos e Instala√ß√£o

1.  **Delphi 12.3 Athens**: √â necess√°rio ter o RAD Studio 12.3 ou Delphi 12.3 instalado.
2.  **Depend√™ncias**: Este projeto pode utilizar depend√™ncias gerenciadas via `Boss` ou `GetIt Package Manager`.
    *   `TestInsight`: Framework para testes unit√°rios.

**Passos para Instala√ß√£o:**
1.  Clone o reposit√≥rio: `git clone https://github.com/your-username/CleanCodeDelphi.git`
2.  Abra o arquivo `CleanCodeDelphi.dproj` no Delphi 12.3.
3.  Instale as depend√™ncias via GetIt, se necess√°rio.
4.  Compile o projeto (Shift + F9).

### üöÄ Executando o Projeto e os Testes

*   **Executar a Aplica√ß√£o**: Pressione `F9` ou v√° em `Run > Run` no IDE do Delphi.
*   **Executar os Testes**:
    1.  Compile o projeto de testes.
    2.  Se estiver usando TestInsight, abra a janela do TestInsight no IDE.
    3.  Clique em `Run All` para executar todos os testes unit√°rios. Os testes garantem que a l√≥gica de dom√≠nio e aplica√ß√£o funciona como esperado, de forma isolada.

### üëç Benef√≠cios da Arquitetura Limpa

*   **Testabilidade**: A inje√ß√£o de depend√™ncia permite substituir implementa√ß√µes reais por mocks, facilitando testes unit√°rios r√°pidos e confi√°veis.
*   **Manutenibilidade**: C√≥digo organizado, coeso e com baixo acoplamento √© mais f√°cil de entender, corrigir e evoluir.
*   **Flexibilidade**: A troca de componentes (ex: mudar de um banco de dados SQL para um NoSQL) se torna mais simples, pois afeta apenas a camada de infraestrutura.
*   **Escalabilidade**: A separa√ß√£o de responsabilidades permite que diferentes partes do sistema evoluam de forma independente.

### ü§ù Como Contribuir

Contribui√ß√µes s√£o muito bem-vindas! Se voc√™ deseja melhorar este projeto:

1.  Fa√ßa um **Fork** do reposit√≥rio.
2.  Crie uma nova **Branch** para sua feature (`git checkout -b feature/AmazingFeature`).
3.  Fa√ßa o **Commit** de suas altera√ß√µes (`git commit -m 'Add some AmazingFeature'`).
4.  Fa√ßa o **Push** para a Branch (`git push origin feature/AmazingFeature`).
5.  Abra um **Pull Request**.

### üìÑ Licen√ßa

Este projeto est√° licenciado sob a Licen√ßa MIT. Veja o arquivo `LICENSE` para mais detalhes.

### üîó Links √öteis e Refer√™ncias

*   **Clean Code: A Handbook of Agile Software Craftsmanship** por Robert C. Martin.
*   **Documenta√ß√£o Oficial do Delphi**: [docwiki.embarcadero.com](https://docwiki.embarcadero.com/RADStudio/en/Main_Page)
*   **Blog da Embarcadero**: [blogs.embarcadero.com](https://blogs.embarcadero.com/)
*   **Reposit√≥rio `delphi-books`**: [github.com/PacktPublishing/Delphi-Books](https://github.com/PacktPublishing/Delphi-Books)