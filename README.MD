## README.md: Clean Code e SOLID com Delphi 12.3 Athens

![Delphi Version](https://img.shields.io/badge/Delphi-12.3%20Athens-blue.svg)![License](https://img.shields.io/badge/License-MIT-green.svg)![Status](https://img.shields.io/badge/Status-Educacional-brightgreen.svg)

Um projeto de refer√™ncia completo demonstrando a aplica√ß√£o dos princ√≠pios **SOLID** e de **Clean Code** utilizando os recursos modernos do **Delphi 12.3 Athens**. O objetivo √© fornecer um guia pr√°tico e did√°tico para a constru√ß√£o de software robusto, manuten√≠vel e test√°vel em Object Pascal.

---

### üìö Tabela de Conte√∫dos

1.  [üéØ Introdu√ß√£o](#-introdu√ß√£o)
2.  [‚ú® Recursos Modernos do Delphi 12.3 para Clean Code](#-recursos-modernos-do-delphi-123-para-clean-code)
3.  [üèóÔ∏è Arquitetura do Sistema](#Ô∏è-arquitetura-do-sistema)
    *   [Diagrama de Arquitetura em Camadas](#diagrama-de-arquitetura-em-camadas)
    *   [Diagrama de Classes (UML)](#diagrama-de-classes-uml)
    *   [Fluxo de Processamento de Pedidos (Sequ√™ncia)](#fluxo-de-processamento-de-pedidos-sequ√™ncia)
4.  [üìÇ Estrutura do Projeto](#-estrutura-do-projeto)
5.  [‚öôÔ∏è Pr√©-requisitos e Instala√ß√£o](#Ô∏è-pr√©-requisitos-e-instala√ß√£o)
6.  [‚ñ∂Ô∏è Como Executar o Projeto](#Ô∏è-como-executar-o-projeto)
7.  [üß™ Como Executar os Testes](#-como-executar-os-testes)
8.  [üß† Princ√≠pios SOLID em A√ß√£o](#-princ√≠pios-solid-em-a√ß√£o)
    *   [1. Single Responsibility Principle (SRP)](#1-single-responsibility-principle-srp)
    *   [2. Open/Closed Principle (OCP)](#2-openclosed-principle-ocp)
    *   [3. Liskov Substitution Principle (LSP)](#3-liskov-substitution-principle-lsp)
    *   [4. Interface Segregation Principle (ISP)](#4-interface-segregation-principle-isp)
    *   [5. Dependency Inversion Principle (DIP)](#5-dependency-inversion-principle-dip)
9.  [üó∫Ô∏è Mindmap dos Princ√≠pios SOLID](#Ô∏è-mindmap-dos-princ√≠pios-solid)
10. [üèÜ Benef√≠cios da Arquitetura Limpa](#-benef√≠cios-da-arquitetura-limpa)
11. [ü§ù Contribui√ß√£o](#-contribui√ß√£o)
12. [üìú Licen√ßa](#-licen√ßa)

---

### üéØ Introdu√ß√£o

Este projeto implementa um sistema simples de processamento de pedidos como um estudo de caso para aplicar os cinco princ√≠pios SOLID. Ele foi desenvolvido e otimizado para **Delphi 12.3 Athens**, aproveitando seus recursos mais recentes para escrever um c√≥digo mais limpo, expressivo e eficiente. Cada princ√≠pio √© demonstrado com exemplos pr√°ticos de "antes" (ruim) e "depois" (bom), facilitando o entendimento dos conceitos.

### ‚ú® Recursos Modernos do Delphi 12.3 para Clean Code

O Delphi 12.3 Athens introduz e aprimora recursos que facilitam a escrita de c√≥digo limpo e moderno. Este projeto os utiliza para:

*   **Infer√™ncia de Tipo com `var`**: Reduz a verbosidade na declara√ß√£o de vari√°veis locais, tornando o c√≥digo mais leg√≠vel.
    ```pascal
    var Validator: IOrderValidator := TOrderValidator.Create; // Cl√°ssico
    var Validator := TOrderValidator.Create; // Moderno com infer√™ncia
    ```
*   **Vari√°veis Inline**: Permite declarar vari√°veis no exato local onde s√£o usadas pela primeira vez, melhorando a localidade de refer√™ncia e a clareza do escopo.
    ```pascal
    if AOrder.IsValid(var ValidationMessage: string) then // Declara√ß√£o inline
    begin
      // Usa ValidationMessage aqui
    end;
    ```
*   **Managed Records**: `record`s com inicializa√ß√£o, finaliza√ß√£o e c√≥pia customizadas permitem criar tipos de dados imut√°veis ou com comportamento complexo sem o overhead de uma `class`, ideal para Entidades e DTOs.
*   **Melhorias na Sintaxe**: Pequenos aprimoramentos, como n√∫meros bin√°rios e separadores em literais num√©ricos (`1_000_000`), contribuem para um c√≥digo mais expressivo.

---

### üèóÔ∏è Arquitetura do Sistema

A arquitetura foi projetada para ser desacoplada e test√°vel, seguindo uma abordagem de Camadas e Clean Architecture. As depend√™ncias sempre apontam para dentro, em dire√ß√£o √†s abstra√ß√µes, nunca para implementa√ß√µes concretas.

#### Diagrama de Arquitetura em Camadas

Este diagrama mostra como as camadas se comunicam. As camadas superiores (como a Aplica√ß√£o) dependem apenas de interfaces definidas nas camadas inferiores, e a Inje√ß√£o de Depend√™ncia fornece as implementa√ß√µes concretas em tempo de execu√ß√£o.

```mermaid
graph TD
    subgraph "Apresenta√ß√£o (UI)"
        A[Console App / DUnitX Tests]
    end

    subgraph "Orquestra√ß√£o (Application)"
        B(TOrderService)
    end

    subgraph "Abstra√ß√µes (Interfaces)"
        C{IOrderValidator}
        D{IOrderCalculator}
        E{IOrderRepository}
        F{INotificationService}
    end

    subgraph "Dom√≠nio"
        G[Entidades: TOrder, TOrderItem]
        H[Exce√ß√µes: EOrderValidationException]
    end

    subgraph "Infraestrutura (Implementa√ß√µes)"
        I[TOrderValidator]
        J[TOrderCalculator]
        K[TMockOrderRepository]
        L[TMockNotificationService]
    end

    A --> B
    B --> C
    B --> D
    B --> E
    B --> F
    B --> G
    C --> G
    D --> G

    I -- implements --> C
    J -- implements --> D
    K -- implements --> E
    L -- implements --> F
```

#### Diagrama de Classes (UML)

Este diagrama UML simplificado ilustra a rela√ß√£o entre as interfaces e suas implementa√ß√µes, destacando os princ√≠pios ISP e DIP.

```mermaid
classDiagram
    direction LR

    class IOrderRepository {
        <<Interface>>
        +Save(order: TOrder)
    }

    class INotificationService {
        <<Interface>>
        +SendConfirmation(order: TOrder)
    }

    class TMockOrderRepository {
        +Save(order: TOrder)
    }

    class TMockNotificationService {
        +SendConfirmation(order: TOrder)
    }

    class TOrderService {
        -FRepository: IOrderRepository
        -FNotifier: INotificationService
        +ProcessOrder(order: TOrder)
    }

    TMockOrderRepository ..|> IOrderRepository : implements
    TMockNotificationService ..|> INotificationService : implements
    TOrderService o-- "1" IOrderRepository : depends on
    TOrderService o-- "1" INotificationService : depends on
```

#### Fluxo de Processamento de Pedidos (Sequ√™ncia)

Mostra a intera√ß√£o entre os objetos durante a execu√ß√£o do m√©todo `ProcessOrder`.

```mermaid
sequenceDiagram
    participant App as Aplica√ß√£o
    participant Service as TOrderService
    participant Validator as IOrderValidator
    participant Calculator as IOrderCalculator
    participant Repo as IOrderRepository
    participant Notifier as INotificationService

    App->>Service: ProcessOrder(Order)
    activate Service
    Service->>Validator: Validate(Order)
    activate Validator
    Validator-->>Service: (Success)
    deactivate Validator

    Service->>Calculator: CalculateTotals(Order)
    activate Calculator
    Calculator-->>Service: (Totals Calculated)
    deactivate Calculator

    Service->>Repo: Save(Order)
    activate Repo
    Repo-->>Service: (Saved)
    deactivate Repo

    Service->>Notifier: SendConfirmation(Order)
    activate Notifier
    Notifier-->>Service: (Sent)
    deactivate Notifier

    Service-->>App: (Order Processed)
    deactivate Service
```

---

### üìÇ Estrutura do Projeto

A estrutura de pastas organiza o projeto por responsabilidades, facilitando a localiza√ß√£o e manuten√ß√£o do c√≥digo.

```
CleanCodeDelphi/
‚îú‚îÄ‚îÄ CleanCodeDelphi.dpr         // Arquivo principal do projeto (Console)
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderEntities.pas   // Entidades de dom√≠nio (TOrder)
‚îÇ   ‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderInterfaces.pas // Todas as interfaces (IOrderValidator, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ exceptions/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CustomExceptions.pas// Exce√ß√µes customizadas
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderValidator.pas  // Implementa√ß√£o da valida√ß√£o (SRP)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderCalculator.pas // Implementa√ß√£o do c√°lculo (SRP)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderService.pas    // Orquestrador principal (DIP)
‚îÇ   ‚îî‚îÄ‚îÄ mocks/
‚îÇ       ‚îú‚îÄ‚îÄ MockOrderRepository.pas // Implementa√ß√£o mock de reposit√≥rio
‚îÇ       ‚îî‚îÄ‚îÄ MockNotificationService.pas // Implementa√ß√£o mock de notifica√ß√£o
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ TestOrderService.pas    // Testes unit√°rios com DUnitX
‚îî‚îÄ‚îÄ examples/
    ‚îî‚îÄ‚îÄ SOLIDExamples.pas       // Arquivo did√°tico com exemplos de SOLID
```

---

### ‚öôÔ∏è Pr√©-requisitos e Instala√ß√£o

*   **IDE**: **Embarcadero Delphi 12.3 Athens** ou superior.
*   **Depend√™ncias**:
    *   **DUnitX**: Para execu√ß√£o dos testes unit√°rios.
        *   Instale facilmente via **GetIt Package Manager** no Delphi.

**Passos para Configura√ß√£o:**

1.  Clone o reposit√≥rio: `git clone https://...`
2.  Abra o Delphi 12.3 Athens.
3.  V√° em `Tools > GetIt Package Manager`.
4.  Procure por `DUnitX` e clique em `Install`.
5.  Abra o arquivo de grupo de projeto (`.groupproj`) ou o projeto principal (`CleanCodeDelphi.dpr`).
6.  No `Project Manager`, clique com o bot√£o direito em `CleanCodeDelphi.exe` e selecione `Build`.

---

### ‚ñ∂Ô∏è Como Executar o Projeto

1.  Compile o projeto `CleanCodeDelphi.dpr`.
2.  Execute o `CleanCodeDelphi.exe` gerado.
3.  O console exibir√° o resultado do processamento de um pedido de exemplo, mostrando cada etapa (valida√ß√£o, c√°lculo, salvamento, notifica√ß√£o).

### üß™ Como Executar os Testes

1.  No `Project Manager`, clique com o bot√£o direito no projeto `TestOrderService.dpr`.
2.  Selecione **`Run`**.
3.  O DUnitX executar√° os testes e exibir√° os resultados em uma janela ou no console, validando o comportamento do `TOrderService` de forma isolada com o uso de mocks.

---

### üß† Princ√≠pios SOLID em A√ß√£o

#### 1. Single Responsibility Principle (SRP)
*Uma classe deve ter um, e apenas um, motivo para mudar.*

*   **Problema**: Uma classe `TOrderProcessor` que valida, calcula, salva e notifica. Mudar a l√≥gica de notifica√ß√£o exige alterar uma classe que tamb√©m lida com regras de neg√≥cio e acesso a dados.
*   **Solu√ß√£o**: Separamos as responsabilidades em classes distintas:
    *   `TOrderValidator`: Apenas valida o pedido.
    *   `TOrderCalculator`: Apenas calcula os totais.
    *   `TOrderService`: Orquestra o fluxo, delegando tarefas para as outras classes.

**Exemplo de C√≥digo (`OrderService.pas`):**
```pascal
// TOrderService apenas orquestra, delegando responsabilidades.
procedure TOrderService.ProcessOrder(const AOrder: TOrder);
begin
  FValidator.Validate(AOrder);
  FCalculator.CalculateTotals(AOrder);
  FRepository.Save(AOrder);
  FNotifier.SendConfirmation(AOrder);
end;
```

#### 2. Open/Closed Principle (OCP)
*Objetos ou entidades devem estar abertos para extens√£o, mas fechados para modifica√ß√£o.*

*   **Problema**: Se um `TDiscountCalculator` tem um `case` ou `if/else` para diferentes tipos de desconto, adicionar um novo desconto exige modificar seu c√≥digo.
*   **Solu√ß√£o**: Criamos uma interface `IDiscountStrategy` e diferentes classes que a implementam. Para um novo desconto, basta criar uma nova classe sem alterar o c√≥digo existente.

**Exemplo de C√≥digo (`SOLIDExamples.pas`):**
```pascal
// Aberto para extens√£o: adicione novas classes de desconto.
// Fechado para modifica√ß√£o: n√£o mexa no TFinalPriceCalculator.
TPercentageDiscount = class(TInterfacedObject, IDiscountStrategy)
  function Calculate(APrice: Double): Double;
end;

TFixedValueDiscount = class(TInterfacedObject, IDiscountStrategy)
  function Calculate(APrice: Double): Double;
end;
```

#### 3. Liskov Substitution Principle (LSP)
*Subtipos devem ser substitu√≠veis por seus tipos base sem alterar a corretude do programa.*

*   **Problema**: Uma classe `Bird` tem um m√©todo `Fly`. A subclasse `Penguin` herda de `Bird`, mas n√£o pode voar. Lan√ßar uma exce√ß√£o no m√©todo `Fly` do `Penguin` viola o LSP.
*   **Solu√ß√£o**: Criar hierarquias mais corretas, como uma classe base `Bird` e subclasses `FlyingBird` e `NonFlyingBird`, onde apenas `FlyingBird` possui o m√©todo `Fly`.

**Exemplo de C√≥digo (`SOLIDExamples.pas`):**
```pascal
// Correto: O subtipo TReadOnlyFile pode substituir TFile sem quebrar o programa.
// Ambos podem ser lidos. Apenas TWritableFile pode ser escrito.
var
  LFile: TFile := TWritableFile.Create('notes.txt');
  LData := LFile.Read; // Funciona

LFile := TReadOnlyFile.Create('config.ini');
LData := LFile.Read; // Tamb√©m funciona. O programa √© correto.
```

#### 4. Interface Segregation Principle (ISP)
*Muitas interfaces espec√≠ficas s√£o melhores do que uma √∫nica interface geral.*

*   **Problema**: Uma interface "gorda" `IWorker` com m√©todos `Work` e `Eat`. Uma classe `TRobotWorker` √© for√ßada a implementar `Eat`, o que n√£o faz sentido.
*   **Solu√ß√£o**: Quebramos a interface em duas: `IWorkable` e `IEatable`. As classes implementam apenas as interfaces que fazem sentido para elas.

**Exemplo de C√≥digo (`OrderInterfaces.pas`):**
```pascal
// Interfaces segregadas e espec√≠ficas.
IOrderValidator = interface
  ['{GUID}']
  procedure Validate(const AOrder: TOrder);
end;

IOrderCalculator = interface
  ['{GUID}']
  procedure CalculateTotals(const AOrder: TOrder);
end;
```

#### 5. Dependency Inversion Principle (DIP)
*M√≥dulos de alto n√≠vel n√£o devem depender de m√≥dulos de baixo n√≠vel. Ambos devem depender de abstra√ß√µes.*

*   **Problema**: `TOrderService` cria inst√¢ncias concretas de `TOrderValidator` e `TMockOrderRepository`. Isso acopla o servi√ßo a implementa√ß√µes espec√≠ficas, dificultando testes e trocas.
*   **Solu√ß√£o**: `TOrderService` passa a depender de interfaces (`IOrderValidator`, `IOrderRepository`). As inst√¢ncias concretas s√£o "injetadas" via construtor (Inje√ß√£o de Depend√™ncia).

**Exemplo de C√≥digo (`OrderService.pas`):**
```pascal
// TOrderService depende de abstra√ß√µes (interfaces), n√£o de classes concretas.
constructor TOrderService.Create(
  const AValidator: IOrderValidator;
  const ACalculator: IOrderCalculator;
  const ARepository: IOrderRepository;
  const ANotifier: INotificationService);
begin
  FValidator := AValidator;
  FCalculator := ACalculator;
  FRepository := ARepository;
  FNotifier := ANotifier;
end;
```

---

### üó∫Ô∏è Mindmap dos Princ√≠pios SOLID

Este mapa mental resume os cinco princ√≠pios, seus objetivos e benef√≠cios.

```mermaid
mindmap
  root((Clean Code))
    **SOLID**
      **S: Single Responsibility**
        ::icon(1)
        Conceito: Uma classe, um motivo para mudar.
        Benef√≠cio: Alta coes√£o, baixo acoplamento.
        Exemplo: TOrderValidator vs TOrderCalculator.
      **O: Open/Closed**
        ::icon(2)
        Conceito: Aberto para extens√£o, fechado para modifica√ß√£o.
        Benef√≠cio: Estabilidade, menos bugs em c√≥digo existente.
        Exemplo: Estrat√©gias de desconto com interfaces.
      **L: Liskov Substitution**
        ::icon(3)
        Conceito: Subtipos devem ser substitu√≠veis por tipos base.
        Benef√≠cio: Hierarquias confi√°veis, polimorfismo seguro.
        Exemplo: Hierarquia de Aves (voadoras e n√£o voadoras).
      **I: Interface Segregation**
        ::icon(4)
        Conceito: Interfaces pequenas e espec√≠ficas.
        Benef√≠cio: Evita classes com m√©todos "vazios".
        Exemplo: IOrderValidator, IOrderCalculator em vez de IOrderManager.
      **D: Dependency Inversion**
        ::icon(5)
        Conceito: Depender de abstra√ß√µes, n√£o de implementa√ß√µes.
        Benef√≠cio: Desacoplamento, testabilidade.
        Exemplo: TOrderService recebendo interfaces via construtor.
```

---

### üèÜ Benef√≠cios da Arquitetura Limpa

*   **Manutenibilidade**: C√≥digo f√°cil de entender e modificar.
*   **Testabilidade**: Unidades de c√≥digo podem ser testadas de forma isolada (unit tests).
*   **Flexibilidade**: Trocar um servi√ßo de e-mail por um de SMS, ou um banco de dados SQL por um NoSQL, torna-se uma tarefa simples.
*   **Escalabilidade**: A estrutura modular facilita a adi√ß√£o de novas funcionalidades sem impactar as existentes.

---

### ü§ù Contribui√ß√£o

Contribui√ß√µes s√£o bem-vindas! Se voc√™ encontrar um bug, tiver uma sugest√£o de melhoria ou quiser adicionar um novo exemplo, por favor, abra uma *issue* ou envie um *pull request*.

---

### üìú Licen√ßa

Este projeto est√° licenciado sob a **Licen√ßa MIT**. Veja o arquivo `LICENSE` para mais detalhes.